- id: 1
  collectionId: 2
  semanticVersion:
    major: 1
    minor: 0
    patch: 0
  title: Palindrom
  author: bje40dc
  text: >
    Erstellen Sie ein Skript, das prüft, ob der übergebene String ein Palindrom darstellt! Ein leerer String ist für
    diese Aufgabe auch ein Palindrom. Ihr Programm soll Groß- und Kleinschreibung ignorieren, d. h. 'a' == 'A'.
  state: APPROVED

  functionName: is_palindrome
  foldername: palindrome
  filename: palindrome

  inputTypes: [{id: 1, inputName: word, inputType: string}]
  outputType: boolean

  unitTestPart:
    unitTestType: Simplified
    unitTestsDescription: TODO!
    unitTestFiles: []
    unitTestTestConfigs: []
    testFileName: test_palindrome.py
    sampleSolFileNames: []

  implementationPart:
    base: |
      def is_palindrome(word: str) -> bool:
          return False
    files:
      - path: palindrome.py
        resourcePath: programming/2-strings/1-palindrome/palindrome_declaration.py
        fileType: python
        editable: true
    implFileName: palindrome.py
    sampleSolFileNames: [palindrome.py]


  sampleSolutions:
    - id: 1
      files:
        - path: palindrome.py
          resourcePath: programming/2-strings/1-palindrome/palindrome.py
          fileType: python
          editable: false

  sampleTestData:
    - {id: 1, inputs: "anna", output: true}
    - {id: 2, inputs: "ananas", output: false}
    - {id: 3, inputs: "", output: true}
    - {id: 4, inputs: "qwertzuiiuztrewq", output: true}
    - {id: 5, inputs: "qwertzuiyiuztrewq", output: true}
    - {id: 6, inputs: "Tacocat", output: true}

  tags:
    - Strings
    - ForLoops

- id: 2
  collectionId: 2
  semanticVersion: {major: 1, minor: 0, patch: 0}
  title: Fließkommazahl in Exponentialschreibweise
  author: bje40dc
  text: >
    <p>
    <code>def format_floating_point_exponential(number: float) -> str:</code>
    </p>
    <p>
    Diese Funktion soll die übergebene Fließkommazahl in Exponentialschreibweise formatieren. Dazu soll die Zahl in der
    Form $x = m \cdot 10^e$ mit der Mantisse $m$ und dem Exponenten $e$ normiert werden. Bei der Darstellung sollen die
    Mantisse und der Exponent dann durch ein <code>e</code> getrennt werden. Es sollen keine Nachkommastellen gerundet werden.
    </p>
    <p>
    Beispiele: $\pi \approx 3.1415 = 3.1415 \cdot 10^0 :=$ <code>3.1415e0</code>
    </p>
    <p>
    Hinweis: Bei mehrfacher Division kann es zu Rundungsfehlern kommen.
    </p>
  state: APPROVED

  functionName: floating_point_exponential
  foldername: floating_point_exponential
  filename: floating_point_exponential
  inputTypes: []
  outputType: None

  unitTestPart:

    unitTestType: Normal

    unitTestsDescription: >

    unitTestFiles:
      - path: floating_point_exponential.py
        resourcePath: programming/2-strings/2-floating_point_exponential/floating_point_exponential_declaration.py
        fileType: python
        editable: false
      - path: test_floating_point_exponential.py
        resourcePath: programming/2-strings/2-floating_point_exponential/test_floating_point_exponential_declaration.py
        fileType: python
        editable: true

    unitTestTestConfigs:
      - id: 0
        shouldFail: false
        description: Musterlösung...
      - id: 1
        shouldFail: true
        description: Die Mantisse soll alle Dezimalstellen beinhalten.
      - id: 2
        shouldFail: true
        description: Die Zahl 10 soll mit der Variable <code>exponent</code> potenziert und nicht multipliziert werden.
      - id: 3
        shouldFail: true
        description: Die Zahl 10 soll mit der Variable <code>exponent</code> potenziert werden.
      - id: 4
        shouldFail: true
        description: Die Ausgabe soll richtig formatiert sein {Mantisse}e{Exponent}.
    testFileName: test_floating_point_exponential.py
    sampleSolFileNames: [test_floating_point_exponential.py]

  implementationPart:
    base: |
      from math import log10


      def format_floating_point_exponential(number: float) -> str:
          pass
    files:
      - path: test_floating_point_exponential.py
        resourcePath: programming/2-strings/2-floating_point_exponential/test_floating_point_exponential.py
        fileType: python
        editable: false
      - path: floating_point_exponential.py
        resourcePath: programming/2-strings/2-floating_point_exponential/floating_point_exponential_declaration.py
        fileType: python
        editable: true
    implFileName: floating_point_exponential.py
    sampleSolFileNames: [floating_point_exponential.py]

  sampleSolutions:
    - id: 1
      files:
        - path: floating_point_exponential.py
          resourcePath: programming/2-strings/2-floating_point_exponential/floating_point_exponential.py
          fileType: python
          editable: false
        - path: test_floating_point_exponential.py
          resourcePath: programming/2-strings/2-floating_point_exponential/test_floating_point_exponential.py
          fileType: python
          editable: false

  sampleTestData: []

  tags:
    - Strings
    - Math

- id: 3
  collectionId: 2
  semanticVersion: {major: 1, minor: 0, patch: 0}
  title: Dateinamen und Endung
  author: bje40dc
  text: >
    <p>
    <code>def file_name_and_ending(filename: str) -> Tuple[str, str]:</code>
    </p>
    <p>
    Diese Funktion bekommt einen Dateinamen übergeben und soll ihn in Dateinamen und Endung (ohne Punkt) trennen. Dabei
    sollen auch Spezialfälle beachtet werden:
    </p>
    <ul>
    <li>
    Es gibt Dateien ohne Endung (z. B. <code>config</code>)
    </li>
    <li>
    Dateien, die mit einem Punkt beginnen (z. B. <code>.gitignore</code>), sind versteckt und haben keine Dateiendung, sondern
    nur einen Namen. Der Punkt gehört zum Namen.
    </li>
    <li>
    Es gibt Dateien mit mehreren Endungen (z. B. <code>application.conf.json</code>)
    </li>
    </ul>
  state: APPROVED

  functionName: file_name_and_ending
  foldername: file_name_and_ending
  filename: file_name_and_ending
  inputTypes: []
  outputType: None

  unitTestPart:

    unitTestType: Normal

    unitTestsDescription: >

    unitTestFiles:
      - path: file_name_and_ending.py
        resourcePath: programming/2-strings/3-file_name_and_ending/file_name_and_ending_declaration.py
        fileType: python
        editable: false
      - path: test_file_name_and_ending.py
        resourcePath: programming/2-strings/3-file_name_and_ending/test_file_name_and_ending_declaration.py
        fileType: python
        editable: true

    unitTestTestConfigs:
      - id: 0
        shouldFail: false
        description: Musterlösung...
      - id: 1
        shouldFail: true
        description: Bei Dateien ohne Endung soll nur der Dateiname und ein leerer String zurückgegeben werden.
      - id: 2
        shouldFail: true
        description: Bei versteckten Dateien soll der Dateiname mit einem vorangestellten Punkt und ein leerer String zurückgegeben werden.
      - id: 3
        shouldFail: true
        description: Bei versteckten Dateien soll nur der Dateiname mit einem vorangstellten Punkt und ein leerer String zurückgegeben werden.
      - id: 4
        shouldFail: true
        description: Bei normalen Dateien soll der Dateiname und die Dateiendung zurückgegeben werden.
      - id: 5
        shouldFail: true
        description: Bei normalen Dateien soll der Dateiname und die Endung in der korrekten Reihenfolge zurückgegeben werden.
      - id: 6
        shouldFail: true
        description: Bei Dateien mit mehreren Endungen soll der Dateiname mit allen Endungen außer der letzten und die letzte Endung ausgegeben werden.
    testFileName: test_file_name_and_ending.py
    sampleSolFileNames: [test_file_name_and_ending.py]

  implementationPart:
    base: |
      from typing import Tuple


      def file_name_and_ending(filename: str) -> Tuple[str, str]:
          pass
    files:
      - path: test_file_name_and_ending.py
        resourcePath: programming/2-strings/3-file_name_and_ending/test_file_name_and_ending.py
        fileType: python
        editable: false
      - path: file_name_and_ending.py
        resourcePath: programming/2-strings/3-file_name_and_ending/file_name_and_ending_declaration.py
        fileType: python
        editable: true
    implFileName: file_name_and_ending.py
    sampleSolFileNames: [file_name_and_ending.py]

  sampleSolutions:
    - id: 1
      files:
        - path: file_name_and_ending.py
          resourcePath: programming/2-strings/3-file_name_and_ending/file_name_and_ending.py
          fileType: python
          editable: false
        - path: test_file_name_and_ending.py
          resourcePath: programming/2-strings/3-file_name_and_ending/test_file_name_and_ending.py
          fileType: python
          editable: false

  sampleTestData: []

  tags:
    - Tuples
    - Strings

- id: 4
  collectionId: 2
  semanticVersion: {major: 1, minor: 0, patch: 0}
  title: Namenssuche
  author: bje40dc
  text: >
    <p>
    <code>def name_search(all_names: List[str], fragment: str) -> List[Tuple[str, str]]:</code>
    </p>
    <p>
    Diese Funktion bekommt eine List von Namen und ein Teil eines Namens übergeben und soll überprüfen, welche der Namen
    das Fragment beinhalten. Für diese Namen soll jeweils das Präfix und das Suffix als Tuple zurückgegeben werden, durch
    die sich durch Konkatenation mit dem Fragment der Name bilden lässt.
    </p>
    <p>
    Beispiel: Für das Fragmen <code>nn</code> und dem Namen <code>anna</code> soll das Tuple <code>('a', 'a')</code> zurückgegeben werden
    </p>
  state: APPROVED

  functionName: name_search
  foldername: name_search
  filename: name_search
  inputTypes: []
  outputType: None

  unitTestPart:

    unitTestType: Normal

    unitTestsDescription: >

    unitTestFiles:
      - path: name_search.py
        resourcePath: programming/2-strings/4-name_search/name_search_declaration.py
        fileType: python
        editable: false
      - path: test_name_search.py
        resourcePath: programming/2-strings/4-name_search/test_name_search_declaration.py
        fileType: python
        editable: true

    unitTestTestConfigs:
      - id: 0
        shouldFail: false
        description: Musterlösung...
      - id: 1
        shouldFail: true
        description: Es soll das korrekte Präfix zurückgegeben werden.
      - id: 2
        shouldFail: true
        description: Es soll das korrekte Suffix zurückgegeben werden.
      - id: 3
        shouldFail: true
        description: Falls das Fragment in mehreren Namen enthalten ist sollen alle Namen zurückgegeben werden.
      - id: 4
        shouldFail: true
        description: Falls das Fragment in keinem Namen enthalten ist soll eine leere Liste zurückgegeben werden.
    testFileName: test_name_search.py
    sampleSolFileNames: [test_name_search.py]

  implementationPart:
    base: |
      from typing import Tuple, List


      def name_search(all_names: List[str], fragment: str) -> List[Tuple[str, str]]:
          pass
    files:
      - path: test_name_search.py
        resourcePath: programming/2-strings/4-name_search/test_name_search.py
        fileType: python
        editable: false
      - path: name_search.py
        resourcePath: programming/2-strings/4-name_search/name_search_declaration.py
        fileType: python
        editable: true
    implFileName: name_search.py
    sampleSolFileNames: [name_search.py]

  sampleSolutions:
    - id: 1
      files:
        - path: name_search.py
          resourcePath: programming/2-strings/4-name_search/name_search.py
          fileType: python
          editable: false
        - path: test_name_search.py
          resourcePath: programming/2-strings/4-name_search/test_name_search.py
          fileType: python
          editable: false

  sampleTestData: []

  tags:
    - Strings
    - Lists
    - Tuples
    - ForLoops

- id: 5
  collectionId: 2
  semanticVersion: {major: 1, minor: 0, patch: 0}
  title: Drei Chinesen
  author: bje40dc
  text: >
    <p>
    <code>def three_chinese(line: str, target_vowel: str) -> str:</code>
    </p>
    <p>
    Diese Funktion soll nach dem Schema des bekannten Kinderliedes 'Drei Chinesen mit nem Kontrabass' im übergebenen
    String <code>line</code> alle Vokale einschließlich der Umlaute ä, ö und ü gegen den angegebenen Vokal <code>target_vowel</code>
    austauschen. Dabei sollen aufeinanderfolgende Vokale auf einen einzigen reduziert werden.
    </p>
  state: APPROVED

  functionName: three_chinese
  foldername: three_chinese
  filename: three_chinese
  inputTypes: []
  outputType: None

  unitTestPart:

    unitTestType: Normal

    unitTestsDescription: >

    unitTestFiles:
      - path: three_chinese.py
        resourcePath: programming/2-strings/5-three_chinese/three_chinese_declaration.py
        fileType: python
        editable: false
      - path: test_three_chinese.py
        resourcePath: programming/2-strings/5-three_chinese/test_three_chinese_declaration.py
        fileType: python
        editable: true

    unitTestTestConfigs:
      - id: 0
        shouldFail: false
        description: Musterlösung...
      - id: 1
        shouldFail: true
        description: Die Vokale sollen durch den übergebenen Vokal ersetzt werden.
      - id: 2
        shouldFail: true
        description: Aufeinanderfolgende Vokale sollen auf einen einzigen Vokal reduziert werden.
      - id: 3
        shouldFail: true
        description: Der Vokal A bzw. a soll durch den übergebenen Vokal ersetzt werden.
      - id: 4
        shouldFail: true
        description: Der Vokal E bzw. e soll durch den übergebenen Vokal ersetzt werden.
      - id: 5
        shouldFail: true
        description: Der Vokal I bzw. i soll durch den übergebenen Vokal ersetzt werden.
      - id: 6
        shouldFail: true
        description: Der Vokal O bzw. o soll durch den übergebenen Vokal ersetzt werden.
      - id: 7
        shouldFail: true
        description: Der Vokal U bzw. u soll durch den übergebenen Vokal ersetzt werden.
      - id: 8
        shouldFail: true
        description: Der Umlaut Ä bzw. ä soll durch den übergebenen Vokal ersetzt werden.
      - id: 9
        shouldFail: true
        description: Der Umlaut Ö bzw. ö soll durch den übergebenen Vokal ersetzt werden.
      - id: 10
        shouldFail: true
        description: Der Umlaut Ü bzw. ü soll durch den übergebenen Vokal ersetzt werden.
    testFileName: test_three_chinese.py
    sampleSolFileNames: [test_three_chinese.py]

  implementationPart:
    base: |
      def three_chinese(line: str, target_vowel: str) -> str:
          pass
    files:
      - path: test_three_chinese.py
        resourcePath: programming/2-strings/5-three_chinese/test_three_chinese.py
        fileType: python
        editable: false
      - path: three_chinese.py
        resourcePath: programming/2-strings/5-three_chinese/three_chinese_declaration.py
        fileType: python
        editable: true
    implFileName: three_chinese.py
    sampleSolFileNames: [three_chinese.py]

  sampleSolutions:
    - id: 1
      files:
        - path: three_chinese.py
          resourcePath: programming/2-strings/5-three_chinese/three_chinese.py
          fileType: python
          editable: false
        - path: test_three_chinese.py
          resourcePath: programming/2-strings/5-three_chinese/test_three_chinese.py
          fileType: python
          editable: false

  sampleTestData: []

  tags:
    - Strings
    - Lists
    - ForLoops

- id: 6
  collectionId: 2
  semanticVersion: {major: 1, minor: 0, patch: 0}
  title: Weihnachtsbaum
  author: bje40dc
  text: >
    <p>
    Ziel dieser Funktion ist es, einen Weihnachtsbaum auf der Konsole auszugeben. Dieser hat jeweils eine Stumpfhöhe und
    eine Kronenhöhe, die jeweils in Zeilen angegeben sind. Die oberste Kronenzeile hat eine Breite von eins, die zweite
    eine Breite von drei, die dritte von fünf, usw. Sie sind jeweils mittig angeordnet.
    </p>
    <p>
    Dazu werden mehrere Funktionen implementiert, die (teilweise) aufeinander aufbauen. Daher ist es empfehlenswert, die
    Funktionen in der hier angegebenen Reihenfolge zu implementieren.
    </p>
    <ul>
    <li>
    <code>def xmas_tree_stub(tree_height: int) -> str:</code>
    <p>
    Diese Funktion zeichnet eine Stumpfzeile. Der Buchstabe für den Stumpf soll sich direkt in der Mitte befinden.
    </p>
    <p>
    Eine Zeile für einen Baum mit einer Kronenhöhe von 3 sieht folgendermaßen aus:
    </p>
    <p>
    <code>stump_height_3 = '#   I   #'</code>
    </p>
    </li>
    </ul>
    <h3>Einfache Version</h3>
    <code>
    simple_tree: str = """\<br>
    #############<br>
    #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<br>
    #&nbsp;&nbsp;&nbsp;&nbsp;***&nbsp;&nbsp;&nbsp;&nbsp;#<br>
    #&nbsp;&nbsp;&nbsp;*****&nbsp;&nbsp;&nbsp;#<br>
    #&nbsp;&nbsp;*******&nbsp;&nbsp;#<br>
    #&nbsp;*********&nbsp;#<br>
    #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<br>
    #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<br>
    #############"""
    </code>
    <br><br>
    <ul>
    <li>
    <code>def xmas_tree_top_simple(row: int, tree_height: int) -> str:</code>
    <p>
    Diese Funktion zeichnet jeweils eine Kronenzeile. Das Argument <code>row</code> gibt dabei den Zeilenindex an, <code>tree_height</code> die
    Kronenhöhe. Die Mitte der Krone befindet sich in der Mitte des Strings.
    </p>
    <p>
    Eine Beispielrückgabe für die dritte Zeile (Index zwei) eines Baumes mit einer Kronenhöhe von drei
    sieht beispielsweise folgendermaßen aus:
    </p>
    <p>
    <code>crown_row_3_height_3 = '# ***** #'</code>
    </p>
    </li>
    <li>
    <code>def xmas_tree_simple(treetop_height: int, stub_height: int) -> str:</code>
    <p>
    Diese Funktion soll einen kompletten Baum zeichnen.
    </p>
    </li>
    </ul>
    <h3>Geschmückte Version</h3>
    <code>
    design_tree: str = """\<br>
    #############<br>
    #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<br>
    #&nbsp;&nbsp;&nbsp;&nbsp;*o*&nbsp;&nbsp;&nbsp;&nbsp;#<br>
    #&nbsp;&nbsp;&nbsp;*J*J*&nbsp;&nbsp;&nbsp;#<br>
    #&nbsp;&nbsp;*o*o*o*&nbsp;&nbsp;#<br>
    #&nbsp;*J*J*J*J*&nbsp;#<br>
    #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<br>
    #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<br>
    #############"""
    </code>
    <br><br>
    <ul>
    <li>
    <code>def xmas_tree_top_design(row: int, treetop_height: int) -> str:</code>
    <p>
    Diese Funktion soll eine geschmückte Kronenzeile zeichnen. Dabei sollen jeder zweite * jeweils mit einem J bei
    einem geraden Zeilenindex oder einem o bei einem ungeraden ersetzt werden.
    </p>
    </li>
    <li>
    <code>def xmas_tree_design(treetop_height: int, stub_height: int) -> str:</code>
    <p>
    Diese Funktion zeichnet jeweils einen geschmückten, kompletten Baum.
    </p>
    </li>
    </ul>
  state: APPROVED

  functionName: xmas_tree
  foldername: xmas_tree
  filename: xmas_tree

  inputTypes: []
  outputType: None

  unitTestPart:

    unitTestType: Normal

    unitTestsDescription: >

    unitTestFiles:
      - path: xmas_tree.py
        resourcePath: programming/2-strings/6-xmas_tree/xmas_tree_declaration.py
        fileType: python
        editable: false
      - path: test_xmas_tree.py
        resourcePath: programming/2-strings/6-xmas_tree/test_xmas_tree_declaration.py
        fileType: python
        editable: true

    unitTestTestConfigs:
      - id: 0
        shouldFail: false
        description: Musterlösung...
      - id: 1
        shouldFail: true
        description: Die Funktion xmas_tree_top_simple soll die Ränder mit einer \# kennzeichnen.
      - id: 2
        shouldFail: true
        description: Die Funktion xmas_tree_top_simple soll den Zwischenraum (kein Rand und kein Weihnachtsbaum) durch die korrekte Anzahl an Leerzeichen füllen.
      - id: 3
        shouldFail: true
        description: Die Funktion xmas_tree_top_simple soll den Weihnachtsbaum durch die korrekte Anzahl an * kennzeichnen.
      - id: 4
        shouldFail: true
        description: Die Funktion xmas_tree_top_design soll die Ränder mit einer \# kennzeichnen
      - id: 5
        shouldFail: true
        description: Die Funktion xmas_tree_top_design soll den Zwischenraum (kein Rand und kein Weihnachtsbaum) durch die korrekte Anzahl an Leerzeichen füllen.
      - id: 6
        shouldFail: true
        description: Die Funktion xmas_tree_top_design soll den Weihnachtsbaum durch die korrekte Anzahl an * kennzeichnen.
      - id: 7
        shouldFail: true
        description: Die Funktion xmas_tree_top_design soll die korrekte Anzahl Dekoration in den Weihnachtsbaum einfügen.
      - id: 8
        shouldFail: true
        description: Die Funktion xmas_tree_stub soll die Ränder mit einer \# kennzeichnen.
      - id: 9
        shouldFail: true
        description: Die Funktion xmas_tree_stub soll den Zwischenraum (kein Rand und kein Stumpf) durch die korrekte Anzahl an Leerzeichen füllen.
      - id: 10
        shouldFail: true
        description: Die Funktion xmas_tree_stub soll den Stumpf durch die korrekte Anzahl an I kennzeichnen.
      - id: 11
        shouldFail: true
        description: Die Funktion xmas_tree_simple soll den korrekten Weihnachtsbaum ohne Dekoration erstellen.
      - id: 12
        shouldFail: true
        description: Die Funktion xmas_tree_simple soll den korrekten Weihnachtsbaum ohne Dekoration erstellen.
      - id: 13
        shouldFail: true
        description: Die Funktion xmas_tree_design soll den korrekten Weihnachtsbaum mit Dekoration erstellen.
      - id: 14
        shouldFail: true
        description: Die Funktion xmas_tree_design soll den korrekten Weihnachtsbaum mit Dekoration erstellen.
    testFileName: test_xmas_tree.py
    sampleSolFileNames: [test_xmas_tree.py]

  implementationPart:
    base: |
      def xmas_tree_top_simple(row: int, tree_height: int) -> str:
          pass


      def xmas_tree_top_design(row: int, tree_height: int) -> str:
          pass


      def xmas_tree_stub(h: int) -> str:
          pass


      def xmas_tree_simple(treetop_height: int, stub_height: int) -> str:
          pass


      def xmas_tree_design(treetop_height: int, stub_height: int) -> str:
          pass
    files:
      - path: test_xmas_tree.py
        resourcePath: programming/2-strings/6-xmas_tree/test_xmas_tree.py
        fileType: python
        editable: false
      - path: xmas_tree.py
        resourcePath: programming/2-strings/6-xmas_tree/xmas_tree_declaration.py
        fileType: python
        editable: true
    implFileName: xmas_tree.py
    sampleSolFileNames: [xmas_tree.py]

  sampleSolutions:
    - id: 1
      files:
        - path: xmas_tree.py
          resourcePath: programming/2-strings/6-xmas_tree/xmas_tree.py
          fileType: python
          editable: false
        - path: test_xmas_tree.py
          resourcePath: programming/2-strings/6-xmas_tree/test_xmas_tree.py
          fileType: python
          editable: false

  sampleTestData: []

  tags:
    - Strings
    - Math
    - ForLoops

- id: 7
  collectionId: 2
  semanticVersion: {major: 1, minor: 0, patch: 0}
  title: A1Z26-Verschlüsselung
  author: bje40dc
  text: >
    <p>
    Bei der A1Z26-"Verschlüsselung" werden die einzelnen Buchstaben des Alphabets mit dem Wert ihrer Position im Alphabet
    ersetzt. So wird zum Beispiel aus einem 'a' eine 1, aus einem 'b' eine 2 und aus einem 'z' eine 26.
    </p>
    <p>
    Anmerkungen:
    <ul>
    <li>
    Bei einer symmetrischen Verschlüsselung wird der selbe Schlüssel für das Ver- und Entschlüsseln der Nachricht benutzt.
    </li>
    <li>
    Bei diesen Aufgaben beschränken wir uns auf Kleinbuchstaben.
    </li>
    <li>
    Ein Wort ist im Kontext dieser Aufgabe eine Menge von Kleinbuchstaben, also zum Beispiel "test", "von" oder "azcasflh".
    </li>
    </ul>
    </p>
    <ul>
    <li>
    <code>def encrypt_letter(letter: str) -> int:</code>
    <p>
    Diese Funktion verschlüsselt einen einzelnen Buchstaben.
    </p>
    </li>
    <li>
    <code>def decrypt_letter(letter: str) -> int:</code>
    <p>
    Diese Funktion entschlüsselt einen einzelnen Buchstaben.
    </p>
    </li>
    <li>
    <code>def encrypt_word(word: str) -> List[int]:</code>
    <p>
    Diese Funktion verschlüsselt ein Wort. Der Übersichtlichkeit wegen soll das Ergebnis als Liste zurückgegeben werden.
    </p>
    </li>
    <li>
    <code>def decrypt_word(word: str) -> List[int]:</code>
    <p>
    Diese Funktion entschlüsselt ein vorher mit <code>encrypt_word</code> verschlüsseltes Wort.
    </p>
    </li>
    </ul>
  state: APPROVED

  functionName: a1z26
  foldername: a1z26
  filename: a1z26
  inputTypes: []
  outputType: None

  unitTestPart:

    unitTestType: Normal

    unitTestsDescription: >

    unitTestFiles:
      - path: a1z26.py
        resourcePath: programming/2-strings/7-a1z26/a1z26_declaration.py
        fileType: python
        editable: false
      - path: test_a1z26.py
        resourcePath: programming/2-strings/7-a1z26/test_a1z26_declaration.py
        fileType: python
        editable: true

    unitTestTestConfigs:
      - id: 0
        shouldFail: false
        description: Musterlösung...
      - id: 1
        shouldFail: true
        description: encrypt_letter soll den übergebenen Buchstaben durch die korrekte Ganzzahl verschlüsseln.
      - id: 2
        shouldFail: true
        description: decrypt_letter soll die übergebene Ganzzahl in den korrekten Buchstaben entschlüsseln.
      - id: 3
        shouldFail: true
        description: encrypt_word soll jeden Buchstaben des übergebenen Wortes verschlüsseln und alle Ganzzahlen in der Liste zurückgegeben.
      - id: 4
        shouldFail: true
        description: encrpyt_word soll die richtigen, im übergebenen Wort enthaltenen, Buchstaben verschlüsseln
      - id: 5
        shouldFail: true
        description: encrypt_word soll bei einem leeren String eine leere Liste zurückgeben.
      - id: 6
        shouldFail: true
        description: decrypt_word soll das gesamte entschlüsselte Wort zurückgeben.
      - id: 7
        shouldFail: true
        description: decrypt_word soll die korrekte Ganzzahl entschlüsseln.
      - id: 8
        shouldFail: true
        description: decrypt_word soll bei einer leeren Liste einen leeren String zurückgeben.
    testFileName: test_a1z26.py
    sampleSolFileNames: [test_a1z26.py]

  implementationPart:
    base: |
      from typing import List

      ord_a: int = ord('a')


      def encrypt_letter(letter: str) -> int:
          pass


      def decrypt_letter(letter: int) -> str:
          pass


      def encrypt_word(word: str) -> List[int]:
          pass


      def decrypt_word(word: List[int]) -> str:
          pass
    files:
      - path: test_a1z26.py
        resourcePath: programming/2-strings/7-a1z26/test_a1z26.py
        fileType: python
        editable: false
      - path: a1z26.py
        resourcePath: programming/2-strings/7-a1z26/a1z26_declaration.py
        fileType: python
        editable: true
    implFileName: a1z26.py
    sampleSolFileNames: [a1z26.py]

  sampleSolutions:
    - id: 1
      files:
        - path: a1z26.py
          resourcePath: programming/2-strings/7-a1z26/a1z26.py
          fileType: python
          editable: false
        - path: test_a1z26.py
          resourcePath: programming/2-strings/7-a1z26/test_a1z26.py
          fileType: python
          editable: false

  sampleTestData: []

  tags:
    - Strings
    - ForLoops
    - Math

- id: 8
  collectionId: 2
  semanticVersion: {major: 1, minor: 0, patch: 0}
  title: Caesar-Verschlüsselung
  author: bje40dc
  text: >
    <p>
    Die <a href="https://de.wikipedia.org/wiki/Caesar-Verschl%C3%BCsselung" target="_blank">Ceasar-Chiffre</a> ist ein einfaches
    Verschlüsselungsverfahren, das, wie der Name schon sagt, von Ceasar erfunden bzw. zumindest benutzt wurde. Dabei wird
    jeder Buchstabe um einen vorher festgelegten Wert (bei Ceasar selbt z. B. 3) "nach hinten geschoben" (rotiert).
    Dabei wird zum Beispiel mit dem Parameter 3 aus einem 'a' ein 'd', aus einem 'b' ein 'e' und so weiter. Sollte man
    über die Grenzen des Alphabets hinausgehen, wird wieder von vorne angefangen. So wird
    beim Parameter 3 aus einem 'x' ein 'a', aus einem 'y' ein 'b' und aus einem 'z' ein 'c'.
    </p>
    <p>
    Anmerkungen:
    <ul>
    <li>
    Bei einer symmetrischen Verschlüsselung wird der selbe Schlüssel für das Ver- und Entschlüsseln der Nachricht benutzt.
    </li>
    <li>
    Bei diesen Aufgaben beschränken wir uns auf Kleinbuchstaben.
    </li>
    <li>
    Ein Wort ist im Kontext dieser Aufgabe eine Menge von Kleinbuchstaben, also zum Beispiel "test", "von" oder "azcasflh".
    </li>
    </ul>
    </p>
    <h3>Klasse <code>CeasarCipher</code></h3>
    <p>
    Implementieren Sie die Klasse <code>CeararCiphre</code>. Diese bekommt im Konstruktor eine Ganzzahl übergeben, die die Anzahl an
    Rotationen darstellt.
    </p>
    <p>
    Implementieren Sie außerdem folgende Methoden:
    </p>
    <ul>
    <li>
    <code>def crypt_letter(self, lower_letter: str) -> str:</code>
    <p>
    Diese Methode ist dafür zuständig, einen einzelnen Buchstaben zu verschlüsseln, also ihn im Alphabet um die
    angegebene Anzahl nach hinten zu rotieren.
    </p>
    </li>
    <li>
    <code>def decrypt_letter(self, lower_letter: str) -> str:</code>
    <p>
    Diese Methode ist das Komplement zu <code>crypt_letter</code> und soll die Verschlüsselung eines einzelnen Buchstaben
    rückgängig machen.
    </p>
    </li>
    <li>
    <code>def crypt_word(self, lower_word: str) -> str:</code>
    <p>
    Diese Methode soll ein ganzes Wort verschlüsseln, also jeden Buchstaben einzeln.
    </p>
    </li>
    <li>
    <code>def decrypt_word(self, lower_word: str) -> str:</code>
    <p>
    Diese Methode soll ein einzelnes Wort entschlüsseln.
    </p>
    </li>
    <li>
    <code>def crypt_text(self, lower_text: str) -> str:</code>
    <p>
    Diese Methode soll einen ganzen Text verschlüsseln. Dazu sollen zuerst die Sätze anhand der Punkte getrennt werden,
    danach die Wörter anhand der Leerzeichen, die Wörter verschlüsselt und alles wieder zusammengesetzt werden.
    </p>
    </li>
    <li>
    <code>def decrypt_text(self, lower_text: str) -> str:</code>
    <p>
    Diese Methode soll einen kompletten Text entschlüsseln.
    </p>
    </li>
    </ul>
    <h3>Methode <code>crack_ceasar</code></h3>
    <p>
    Um zu testen, wie einfach die Ceasar-Verschlüsselung zu knacken ist, wollen wir einen
    einfachen <a href="https://de.wikipedia.org/wiki/W%C3%B6rterbuchangriff" target="_blank">Wörterbuchangriff</a> programmieren.
    </p>
    <ul>
    <li>
    <code>def crack_ceasar(encrypted_text: str) -> Optional[str]</code>
    <p>
    Die Funktion bekommt einen zu knackenden, verschlüsselten String übergeben. Sie soll ihn mit den möglichen
    Rotationsanzahlen (1 bis 25) entschlüsseln und überprüfen, ob der Text mit einem der unten angegeben Wörter startet.
    Falls ja, ist das Knacken (sehr wahrscheinlich) erfolgreich und der entschlüsselte Satz soll zurückgegeben werden.
    Wird keine passende Konfiguration gefunden, ist das Wörterbuch nicht groß genug und es soll <code>None</code> zurückgegeben werden.
    </p>
    <p>
    Verwenden Sie folgendes <b>Wörterbuch</b>: <code>ich, du, er, sie, es, wir, ihr, sie, der, die, das</code>
    </p>
    </li>
    </ul>
  state: APPROVED

  functionName: ceasar
  foldername: ceasar
  filename: ceasar

  inputTypes: []
  outputType: None

  unitTestPart:

    unitTestType: Normal

    unitTestsDescription: >
      TODO

    unitTestFiles:
      - path: ceasar.py
        resourcePath: programming/2-strings/8-ceasar/ceasar_declaration.py
        fileType: python
        editable: false
      - path: test_ceasar.py
        resourcePath: programming/2-strings/8-ceasar/test_ceasar_declaration.py
        fileType: python
        editable: true

    unitTestTestConfigs:
      - id: 0
        shouldFail: false
        description: Musterlösung...
    testFileName: test_ceasar.py
    sampleSolFileNames: [test_ceasar.py]

  implementationPart:
    base: |
      from typing import Optional


      class CeasarCipher:
          point_a = ord("a")

          def __init__(self, rounds: int):
              self.rounds: int = rounds

          def crypt_letter(self, lower_letter: str) -> str:
              pass

          def decrypt_letter(self, lower_letter: str) -> str:
              pass

          def crypt_word(self, lower_word: str) -> str:
              pass

          def decrypt_word(self, lower_word: str) -> str:
              pass

          def crypt_text(self, text_lower: str) -> str:
              pass

          def decrypt_text(self, text_lower: str) -> str:
              pass


      word_list = ["ich", "du", "er", "sie", "es", "wir", "ihr", "sie", "der", "die", "das"]


      def crack_ceasar(encrypted_text: str) -> Optional[str]:
          pass
    files:
      - path: test_ceasar.py
        resourcePath: programming/2-strings/8-ceasar/test_ceasar.py
        fileType: python
        editable: false
      - path: ceasar.py
        resourcePath: programming/2-strings/8-ceasar/ceasar_declaration.py
        fileType: python
        editable: true
    implFileName: ceasar.py
    sampleSolFileNames: [ceasar.py]

  sampleSolutions:
    - id: 1
      files:
        - path: ceasar.py
          resourcePath: programming/2-strings/8-ceasar/ceasar.py
          fileType: python
          editable: false
        - path: test_ceasar.py
          resourcePath: programming/2-strings/8-ceasar/test_ceasar.py
          fileType: python
          editable: false

  sampleTestData: []

  tags:
    - Math
    - Strings
    - Classes
